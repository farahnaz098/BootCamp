# -*- coding: utf-8 -*-
"""Numpy_and_Plotting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMdpwmzpP9lQa_ASliBFhahRBgod0zSL

# Numpy and Matplotlib


---




**Numpy** is a numerical calculus and algebra package that is widely used, notably providing the *array* (vector/matrix format) type used in almost all numerical projects.  [Documentation](https://numpy.org/doc/stable/) and [Reference](https://numpy.org/doc/stable/reference/index.html)


**Matplotlib** is a module for generating 2D and 3D graphics. [Documentation ](https://matplotlib.org/stable/contents.html)


It is common to import them with the respective nicknames **np** and **plt** (for `matplotlib.pyplot`).
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

# %matplotlib inline

"""The last line `%matplotlib inline` is a command for Jupyter to indicate that we want our figures in the notebook and not in a separate window.

## Numpy *arrays*

In Numpy, the type *array* is used for vector, matrices, tensors (a matrix type also exists but is more seldomly used).

Numpy arrays can be defined either directly from a list or outputted by a function.


### One-dimensional arrays
"""

x = np.array([1, 2.5, 5, 10])
print(x,type(x))

y = np.random.rand(4)
print(y,type(y))

"""## Plotting

Visualizing the data is quite simple with pyplot:
* Initialize a figure with  `plt.figure()`
* Plot something with ... `plt.plot` (see the [documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.html?highlight=pyplot#module-matplotlib.pyplot) )
* Fix labels, titles, axes
* Eventually save the result with `plt.savefig`
* Show the figure with `plt.show()`
"""

plt.figure()

plt.plot(x,y, 'g--', label='y(x)')

plt.legend(loc='lower right')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Sample Figure')
plt.xlim([0, 10])
plt.ylim([0, 1])
plt.show()

"""## Matrices

Matrices are simply 2D arrays. Since vectors and matrices share the same type, the notion of *shape* is very important.
"""

M = np.array([[0.25, 6.2, 1, 10],[12, 6.2, 6, -5.3]])
print(M,type(M))

print(x,type(x))

"""* The `size` of an array is the number of elements while the `shape` gives how they are arranged."""

print(x.size)  # or equivalently np.size(x)
print(M.size)

print(x.shape)  # or equivalently np.shape(x)
print(M.shape)

"""* The element access, assignment, type, copy is common and similar to the list type."""

print(x)
print(x[2],x[-1])
print(x[::-1])
x[0] = 6.1554
print(x)

v = x
w = np.copy(x)
print(v)
x[0]=1
print(v)
print(w)

print(M)
print(M[1,2],type(M[1,2]))
print(M[1,:],type(M[1,:]),M[1,:].shape)
print(M[1])
print(M[:,0])

"""Advanced access to content and modification is possible"""

x = np.array([1, 2.5, 5, 10])
ind = [0,2,3]
print(x[ind])

"""### Advanced array properties [*]


An array has a *type* that can be accessed with <tt>dtype</tt>, it the combination of a base type (<tt>int, float, complex, bool, object,</tt> etc.) and a precision in bits (<tt>int64, int16, float128, complex128</tt>)
"""

print(x.dtype)

"""Array only accept they casting to their own type. However, the type of an array can be changed."""

try:
    x[0] = 1 + 2.0j
except Exception as e:
    print(e)

y = x.astype(complex)
y[0] = 1 + 2.0j
print(y,type(y),y.dtype)

"""## Numpy array generation

See the corresponding [documentation](https://numpy.org/doc/stable/user/basics.creation.html)

### Number sequences


`arange` returns an array of evenly spaced number from `start` to (at most) `stop` with a fixed jump `step`


`linspace` returns an array of evenly spaced number from `start` to (exactly) `stop` with a fixed number of points `num`
"""

x = np.arange(0, 10, 1.5)
print(x,type(x))

y = np.linspace(0, 10, 25)
print(y,type(y))

"""### Zeros and Ones


`zeros` returns an array (of floats) of zeros  of the precised `shape`

`ones`  returns an array (of floats) of ones  of the precised `shape`

`eye`  returns a square 2D-array (of floats) with ones on the diagonal and zeros elsewhere  
"""

x = np.zeros(3)
print(x,x.shape,type(x),x.dtype)

x = np.zeros((3,))
print(x,x.shape,type(x),x.dtype)

try:
    x = np.zeros(3,3) # This causes an error as 3,3 is not a shape, it is (3,3) -> double parentheses
except Exception as error:
    print(error)

print(x,x.shape,type(x),x.dtype)

x = np.zeros((3,3))
print(x,x.shape,type(x),x.dtype)

y = np.ones(2)
y

M = np.eye(3)
print(M,M.shape,type(M),M.dtype)

"""### Random data


Random arrays can be generated by Numpy's [random](https://numpy.org/doc/stable/reference/random/index.html) module.


`rand` returns an array (of floats) of uniformly distributed numbers in [0,1)  of the precised dimension

`randn`  returns an array (of floats) of numbers from the normal distribution of the precised dimension

`randint`  returns an array (of floats) of integers from the discrete uniform distribution
"""

np.random.rand(5)

np.random.randn(5,2)

np.random.randint(0,100,size=(10,))

a = np.random.randn(10000)
plt.figure()
plt.hist(a,40) # histogram of a with 40 bins
plt.show()

"""## Operations on Matrices and vectors

"""

v = np.arange(0, 5)
print(v)

v * 2

v + 2.5

square = v**2
root = np.sqrt(v)
print(square,root)

plt.figure()
plt.subplot(1,2,2)
plt.plot(square,'g--', label='$y = x^2$')
plt.legend(loc=0)
plt.subplot(1,2,1)
plt.plot(root, 'r*-', label='$y = \sqrt{x}$')
plt.legend(loc=2)
plt.show()

A = np.array([[n+m*10 for n in range(5)] for m in range(4)])
print(A)

A*2

A+2.5

"""Matrices can be visualized as images."""

C = np.random.randn(100,100)
plt.figure()
plt.imshow(C)
plt.colorbar()
plt.show()

"""## Matrix and vector operations



*Warning:* Operation symbols `+   -   *  /` correspond to *elementwise* operations! To perform, matrix/vector multiplication, dedicated function must be used.

### Elementwise operations
"""

A = np.array([[n+m*10 for n in range(5)] for m in range(4)])
v = np.random.randint(0,5,5)
print(A,v)

A*A

v*v

A*v

"""### Transposition

It can be useful to transpose, it is simply done by suffixing `.T` (or equivalently using the function `np.transpose`). Similarly `.H` is the Hermitian conjugate,  `.imag`  `.real` are the real and imaginary parts and  `.abs` the modulus (their *full* versions are respectively `np.conjugate`, `np.imag`, etc.)
"""

print(A,A.shape)
print(A.T,A.T.shape)

"""### Matrix/vector operations

$y=Av$ can be obtained by `y = A.dot(v)` (or equivalently `y = np.dot(A,v)`). This methods works for array with *compatible shape* (matrix-matrix, matrix-vector, vector-matrix, vector-vector, etc).

"""

y = np.dot(A,v)
print(A,A.shape,v,v.shape)
print(y,type(y),y.shape)

"""Example of vector-vector multiplication i.e. a scalar product"""

s = v.dot(v)
print(v, s, type(s))

"""Example of non-compatible shapes"""

try:
    A2 = np.dot(A,A)
except Exception as error:
    print(error)

A3 = np.dot(A,A.T)
print(A3,A3.shape)

"""From a vector $v$, one can form the matrix $P=v v^T$ by `A=v.outer(v)` (or equivalently `np.outer(v,v)`)"""

P = np.outer(v,v)
print(P)

"""### Useful Functions

See the Documentation on [arrays](https://numpy.org/doc/stable/reference/arrays.ndarray.html)  and  [array creation](https://numpy.org/doc/stable/reference/routines.array-creation.html).

*Warning:* Modificators such as transpose, reshape, etc. do not modify the matrix, if you want to keep the result of the operation, you have to assign a variable to it. The notable exceptions are precised as *in-place* in the documentation.
"""

A.reshape((2,10))

print(A)

B = A.flatten()
print(B)

print(A.trace(),A.max(),A.argmax())

"""Some functions may be taken with respects to the columns with <tt>axis=0</tt> or lines with <tt>axis=1</tt>."""

print(A.mean(),A.mean(axis=0),A.mean(axis=1))

print(A.var(),A.var(axis=0),A.std(axis=1))

"""### Repetition, concatenation"""

a = np.array([[1, 2], [3, 4]])
a

b = np.array([[5, 6]])
b

np.concatenate((a, b), axis=0)

np.concatenate((a, b.T), axis=1)

np.vstack((a,b))

np.hstack((a,b.T))

"""### Iterating on arrays"""

v = np.array([1,2,3,4])

for element in v:
    print(element)

a = np.array([[1,2], [3,4]])

for row in a:
    print("row", row)

    for element in row:
        print(element)

"""<tt>enumerate</tt> can be used to get indexes along with elements."""

for row_idx, row in enumerate(a):
    print("row_idx", row_idx, "row", row)

    for col_idx, element in enumerate(row):
        print("col_idx", col_idx, "element", element)

        # update the matrix a: square each element
        a[row_idx, col_idx] = element ** 2

a

"""# 3- Linear Algebra


Numpy comes with an efficient linear algebra module named `linalg` (see the [documentation](https://numpy.org/doc/stable/reference/routines.linalg.html) ). As in many languages, the more vectorized the operations are, the more efficient.

## Decompositions


* *QR:* `linalg.qr` Factor the matrix $A$ as $QR$, where $Q$ is orthonormal and $R$ is upper-triangular.
* *Cholesky:* `linalg.cholesky` Return the Cholesky decomposition, $L L^H$, of the square matrix $A$, where $L$ is lower-triangular. $A$ must be Hermitian and positive-definite. Only $L$ is actually returned.
* *SVD:* `linalg.svd`  Factors the matrix $A$ as $U  \text{diag}(s) V$, where $U$ and $V$ are unitary and $s$ is a 1-d array of $A$â€˜s singular values.


"""

A = np.random.randn(3,2)

Q, R = np.linalg.qr(A)
print(A)

print('\n')
print(Q)

print('\n')
print(R)

import numpy as np

A = np.array([[1, 2],
              [3, 4],
              [5, 6]])

Q, R = np.linalg.qr(A)

print("Q Matrix:\n", Q)
print("R Matrix:\n", R)

np.allclose(A, np.dot(Q, R)) # check that A=QR

U, s, V = np.linalg.svd(A)
print(U.shape, V.shape, s.shape)

S = np.zeros(A.shape)
S[:A.shape[1], :A.shape[1]] = np.diag(s)
np.allclose(A, np.dot(U, np.dot(S, V)))

"""By default, $U$ and $V$ have the shapes $(M, M)$ and $(N, N)$  respectively if $A$ is $(M,N)$. If `full_matrices=False` is passed, the shapes are $(M, K)$ and $(K, N)$, respectively, where $K = min(M, N)$."""

U, s, V = np.linalg.svd(A, full_matrices=False)
print(U.shape, V.shape, s.shape)

S = np.diag(s)
np.allclose(A, np.dot(U, np.dot(S, V)))

"""## Eigenvalues

`linalg.eig` compute the eigenvalues and right eigenvectors of a square array and is the main function (`linalg.eigvals` computes eigenvalues of a non-symmetric array, `linalg.eigh` returns eigenvalues and eigenvectors of a symmetric or Hermitian array).
"""

A = np.array([[1, -1], [1, 1]])
print(A)
l, v = np.linalg.eig(A)
print(l); print(v)

A.dot(v[:,0])

"""We can check that $Ax= \lambda x$."""

np.allclose(A.dot(v[:,0]),l[0]*v[:,0])

"""## Norms and other numbers

The function `linalg.norm` is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the `ord` parameter.

<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="47%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ord</th>
<th class="head">norm for matrices</th>
<th class="head">norm for vectors</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>None</td>
<td>Frobenius norm</td>
<td>2-norm</td>
</tr>
<tr class="row-odd"><td>&#8216;fro&#8217;</td>
<td>Frobenius norm</td>
<td>&#8211;</td>
</tr>
<tr class="row-even"><td>&#8216;nuc&#8217;</td>
<td>nuclear norm</td>
<td>&#8211;</td>
</tr>
<tr class="row-odd"><td>inf</td>
<td>max(sum(abs(x), axis=1))</td>
<td>max(abs(x))</td>
</tr>
<tr class="row-even"><td>-inf</td>
<td>min(sum(abs(x), axis=1))</td>
<td>min(abs(x))</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>&#8211;</td>
<td>sum(x != 0)</td>
</tr>
<tr class="row-even"><td>1</td>
<td>max(sum(abs(x), axis=0))</td>
<td>as below</td>
</tr>
<tr class="row-odd"><td>-1</td>
<td>min(sum(abs(x), axis=0))</td>
<td>as below</td>
</tr>
<tr class="row-even"><td>2</td>
<td>2-norm (largest sing. value)</td>
<td>as below</td>
</tr>
<tr class="row-odd"><td>-2</td>
<td>smallest singular value</td>
<td>as below</td>
</tr>
<tr class="row-even"><td>other</td>
<td>&#8211;</td>
<td>sum(abs(x)$^{ord}$)$^{(1./ord)}$</td>
</tr>
</tbody>
</table>
"""

a = np.arange(9) - 4
B = a.reshape((3, 3))

print(a)
print("none \t",np.linalg.norm(a))
print("2 \t",np.linalg.norm(a,ord=2))
print("1 \t",np.linalg.norm(a,ord=1))
print("inf \t",np.linalg.norm(a,ord=np.inf))
print("0 \t",np.linalg.norm(a,ord=0))

print(B)
print("none \t",np.linalg.norm(B))
print("2 \t",np.linalg.norm(B,ord=2))
print("1 \t",np.linalg.norm(B,ord=1))
print("inf \t",np.linalg.norm(B,ord=np.inf))
print("fro \t",np.linalg.norm(B,ord='fro'))

"""Other useful function include the condition number `linalg.cond`, or rank `linalg.matrix_rank` ."""

A = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]]) # some matrix
I = np.eye(4) # identity
Def =  np.eye(4); Def[0,0]=0 # rank deficient

print(np.linalg.cond(A), np.linalg.cond(I))

np.linalg.cond(Def)

print(np.linalg.matrix_rank(A), np.linalg.matrix_rank(I), np.linalg.matrix_rank(Def))

"""#Practice Tasks"""

#Create a NumPy array of integers from 1 to 10.
int_array = np.arange(1,11)
print(int_array)
int_array.reshape(2,5)

#Use the .reshape() method to change the shape of the array to a 2x5 matrix.

#Create a 5x5 NumPy array filled with random integers between 1 and 100.
five_by_five = np.random.randint(1,100,size=(5,5))
print(f"five_by_five{five_by_five}")

#Extract the middle 3x3 section of the array using slicing.
middle = five_by_five[1:4]
print(f"Middle{middle}")

#Given two arrays: a = np.array([1, 2, 3, 4, 5]) and b = np.array([6, 7, 8, 9, 10]), compute the element-wise sum, difference, product, and division of a and b.
a = np.array([1, 2, 3, 4, 5])
b = np.array([6, 7, 8, 9, 10])

# Element-wise sum
sum_result = a + b

# Element-wise difference
difference = a - b

# Element-wise product
product = a * b

# Element-wise division
division = a / b

print("Element-wise Sum:", sum_result)
print("Element-wise Difference:", difference)
print("Element-wise Product:", product)
print("Element-wise Division:", division)

#Plot the sine wave for x values ranging from 0 to 2*pi. Use 100 points and display the plot with appropriate labels for the x and y axes.
sine_wave = np.linspace(0, 2 * np.pi, 100)

# print(sine_wave,"\n")
plt.plot(sine_wave, np.sin(sine_wave))
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.title('Sine Wave')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0, 10)
y = x**2

categories = ["Category A", "Category B", "Category C"]
value_one = [10, 20, 30]
value_two = [2, 3, 4]

x_indices = np.arange(len(categories))  # Numeric x locations for the groups
bar_width = 0.35  # Width of each bar

plt.figure(figsize=(10, 8))

# Line Plot
plt.subplot(2, 2, 1)
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y = x^2')
plt.title('Line Plot')

# Scatter Plot
plt.subplot(2, 2, 2)
plt.scatter(x, y)
plt.xlabel('x')
plt.ylabel('y = x^2')
plt.title('Scatter Plot')

# Grouped Bar Chart
plt.subplot(2, 2, 3)
plt.bar(x_indices - bar_width/2, value_one, width=bar_width, label='Value One')
plt.bar(x_indices + bar_width/2, value_two, width=bar_width, label='Value Two')
plt.xticks(x_indices, categories)  # Set category names on x-axis
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Grouped Bar Chart')
plt.legend()

# Histogram
plt.subplot(2, 2, 4)
plt.hist(np.random.randn(1000), bins=30)
plt.xlabel('Values')
plt.ylabel('Frequency')
plt.title('Histogram')

plt.tight_layout()
plt.show()

#Create a NumPy array of 50 random numbers. Use np.mean(), np.median(), and np.std() to compute the mean, median, and standard deviation of the array.
temp_array = np.random.randn(50)
print(temp_array)
print(np.mean(temp_array))
print(np.median(temp_array))
print(np.std(temp_array))

#Plot a pie chart showing the distribution of data in a given list of categories, e.g., ['Math', 'Science', 'History', 'English'], with random values for each category.
subject = ['Math', 'Science', 'History', 'English']
marks = np.random.randint(1,100,4)

plt.pie(marks,labels=subject)
plt.show()

#Create a 3x3 matrix filled with random integers between 1 and 10.
M3 = np.random.randint(1,210,size=(3,3))
print(M3,"\n")

#Transpose the matrix and then find the sum of each column.
t_of_M3 = M3.T
t_of_M3

#Write a function that takes a NumPy array and returns the array after squaring all the elements.
a = np.arange(1,10)
squared_a = np.square(a)
print(squared_a)

#Create a 5x5 NumPy array with random values and introduce some NaN (Not a Number) values.
import numpy as np

# Step 1: Create a 5x5 array with random values
arr = np.random.rand(5, 5)

# Step 2: Introduce NaN values at random positions
# Let's introduce 5 NaNs randomly
num_nans = 5
indices = np.random.choice(arr.size, num_nans, replace=False)
arr.flat[indices] = np.nan

print(arr,"\n")

#Use NumPy functions to fill in the NaN values with the column mean of the array.
mean = np.nanmean(arr,axis=0)

ncol = np.where(np.isnan(arr))

arr[ncol] = mean[ncol[1]]

print(arr)

